<?xml version="1.0" encoding="utf-8"?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня автентифікація виникає, коли вебсайт дозволяє зловмиснику отримати доступ до конфіденційного вмісту або функціональних можливостей без необхідності належної автентифікації. Вебінструменти адміністрування є гарним прикладом вебсайтів, які надають доступ до конфіденційних функцій. Залежно від конкретного онлайн-ресурсу, ці вебпрограми не повинні бути напряму доступні без вимоги користувача належним чином підтвердити свою особу.

Щоб обійти налаштування автентифікації, деякі ресурси захищено шляхом "приховування" конкретного розташування та не пов'язування розташування з основним вебсайтом чи іншими у громадських місцях. Однак цей підхід є нічим іншим, як "Безпека через невідомість". Важливо зрозуміти, що навіть якщо ресурс невідомий зловмиснику, він все одно залишається доступним безпосередньо через певну URL-адресу. Конкретну URL-адресу можна виявити через метод прямого добору для пошуку звичайних файлів і каталогів (наприклад, /admin), повідомлень про помилку, журнали джерел переходу або документації, таких як файли довідки. Ці ресурси, незалежно від того, керуються вони вмістом чи функціональністю, мають бути належним чином захищені.</desc>
	<solution>Фаза: архітектура та дизайн
Використовуйте систему автентифікації або бібліотеку, таку як функція автентифікації OWASP ESAPI.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня авторизація виникає, коли програма не виконує адекватних перевірок авторизації, щоб переконатися, що користувач виконує функцію або отримує доступ до даних у спосіб, який узгоджується з політикою безпеки. Процедури авторизації мають забезпечувати виконання того, що дозволено робити користувачеві, службі чи програмі. Коли користувач автентифікований на вебсайті, це не обов’язково означає, що він повинен мати повний доступ до всього вмісту та функцій.

Недостатня авторизація функції

Багато програм надають різним користувачам різні функціональні можливості.
 Сайт новин дозволить користувачам переглядати новини, але не публікувати їх. Бухгалтерська система матиме різні дозволи для службовця з питань кредиторської заборгованості та працівника з питань дебіторської заборгованості. Недостатня авторизація функцій виникає, коли програма не перешкоджає користувачам отримати доступ до функціональних можливостей програми, порушуючи політику безпеки.

Яскравим прикладом стало зламування процесу подачі заявок у Гарвардську школу бізнесу у 2005 році. Помилка авторизації дозволила користувачам переглядати власні дані, хоча вони не повинні були мати доступ до цієї частини вебсайту.
 
Недостатня авторизація даних

Багато програм розкривають базові ідентифікатори даних в URL-адресі. Наприклад, під час доступу до медичної карти в системі можна мати таку URL-адресу:

http://example.com/RecordView?id=12345

Якщо програма не перевіряє, чи автентифікований користувач має права на читання, вона може показувати користувачеві дані, які користувач не повинен бачити.

Недостатня авторизація даних є більш поширеною, ніж недостатня авторизація функцій, оскільки програмісти зазвичай мають повні знання про функціональні можливості програми, але не завжди мають повний показ всіх даних, до яких програма матиме доступ. Програмісти часто мають жорсткий контроль над механізмами авторизації функцій, але покладаються на інші системи, такі як бази даних для виконання авторизації даних.</desc>
	<solution>Фази: Архітектура та Дизайн; Операція
Дуже ретельно керуйте налаштуванням, керуванням і обробкою привілеїв. Явно керуйте зонами довіри в програмному забезпеченні.

Фаза: Архітектура та Дизайн
Переконайтеся, що відповідна класифікація вбудована в проєктування системи, і що класифікація служить для забезпечення та подальшого посилення привілеїв розділення функції. Архітектори та дизайнери повинні покладатися на принцип найменших привілеїв, щоб вирішити, коли доцільно використовувати та відмовитися від системних привілеїв.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Переповнення цілих чисел</alert>
	<desc>Переповнення цілого числа- це умова, що виникає, коли результат арифметичної операції, наприклад множення або додавання, перевищує максимальний розмір типу цілого числа, який використовується для його зберігання. Коли відбувається переповнення цілого числа, здається, що інтерпретоване значення "обернуло" максимальне значення та розпочалося знову з мінімального значення, подібно до годинника, який показує 13:00, вказуючи на 1:00.

Наприклад, 8-розрядне число зі знаком на більшості поширених комп'ютерних побудов має максимальне значення 127 і мінімальне значення -128. Якщо програміст зберігає значення 127 у такій змінній і додає до нього 1, результат має бути 128. Однак це значення перевищує максимальне для цього типу цілого числа, тому інтерпретоване значення буде  "розгорнуто" і стане -128.</desc>
	<solution>Фаза: Вимоги
Переконайтеся, що всі протоколи чітко визначені, щоб усю поведінку поза межами можна було легко ідентифікувати, і вимагають суворої відповідності протоколу.

Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Якщо можливо, виберіть мову або компілятор, який виконує автоматичну перевірку меж.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Використовуйте бібліотеки або структури, які полегшують обробку чисел без неочікуваних наслідків.
Приклади включають безпечні пакети обробки цілих чисел, такі як Safelnt (C++) або IntegerLib (C або C++).

Фаза: Впровадження
Виконайте перевірку будь-якого числового введення, переконавшись, що воно знаходиться в очікуваному діапазоні. Переконайтеся, що вхідні дані відповідають як мінімальним, так і максимальним вимогам для очікуваного діапазону.
Використовуйте цілі числа без знаку, де це можливо. Це спрощує виконання перевірки працездатності для переповнень цілих чисел. Якщо необхідно використовувати цілі числа зі знаком, переконайтеся, що ваша перевірка діапазону містить як мінімальні, так і максимальні значення.

Фаза: Впровадження
Зрозумійте базове представлення вашої мови програмування та те, як воно взаємодіє з числовими розрахунками (CWE-681). Зверніть особливу увагу на розбіжності в розмірі байтів, точність, відмінності зі знаком/ без знаку, зріз, перетворення та приведення між типами, обчислення "не числа" та те, як ваша мова обробляє числа, які є занадто великими для свого основного представлення.
Також уважно враховуйте 32-бітні, 64-бітні та інші потенційні відмінності, які можуть вплинути на числове представлення.

Фаза: Впровадження
Уважно вивчіть попередження компілятора та усуньте потенційно критичні проблеми безпеки, такі як невідповідність знака/без знаку. Навіть якщо слабкість рідко вдається використати, один збій може призвести до зламу всієї системи.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Недостатній захист транспортного рівня</alert>
	<desc>Недостатній захист транспортного рівня
Недостатній рівень захисту транспортного рівня дозволяє комунікації бути відкритим для ненадійних третіх сторін, створюючи вектор атаки для компрометації вебпрограми та/або викрадення конфіденційної інформації. Вебсайти зазвичай використовують Secure Sockets Layer / Transport Layer Security (SSL/TLS) для забезпечення шифрування на транспортному рівні. Однак, якщо вебсайт не налаштовано на використання SSL/TLS і не налаштовано на належне використання SSL/TLS, вебсайт може бути вразливим до перехоплення та модифікації трафіку.
 
Відсутність шифрування транспортного рівня
Коли транспортний рівень не зашифрований, усі повідомлення між вебсайтом і клієнтом надсилаються у відкритому вигляді, що залишає його відкритим для перехоплення, введення та перенаправлення (також відомого як атака "людина посередині"/MITM). Зловмисник може пасивно перехопити зв’язок, отримавши доступ до будь-яких конфіденційних даних, які передаються, наприклад імен користувачів і паролів. Зловмисник також може активно вводити/вилучати вміст зі зв’язку, дозволяючи зловмиснику підробляти та пропускати інформацію, впроваджувати шкідливі сценарії або змусити клієнта отримати доступ до віддаленого ненадійного вмісту. Зловмисник також може перенаправити зв’язок таким чином, що вебсайт і клієнт більше не спілкуються один з одним, а натомість несвідомо спілкуються зі зловмисником у контексті іншої довіреної сторони.

Слабка підтримка шифру
Історично експорт високоякісної криптографії за межі Сполучених Штатів був обмежений. Через це вебсайти були налаштовані на підтримку слабких криптографічних параметрів для тих клієнтів, які були обмежені використанням лише слабких шифрів. Слабкі шифри вразливі до атак через відносну легкість їх зламу; менш ніж два тижні на звичайному домашньому комп’ютері та кілька секунд із використанням спеціального обладнання.
Сьогодні всі сучасні браузери та вебсайти використовують набагато надійніше шифрування, але деякі вебсайти все ще налаштовані на підтримку застарілих слабких шифрів. Через це зловмисник може змусити клієнта повернутися до слабшого шифру під час підключення до вебсайту, дозволяючи зловмиснику зламати слабке шифрування. З цієї причини сервер має бути налаштований на прийняття лише надійних шифрів і не надавання послуг будь-якому клієнту, який запитує використання слабшого шифру. Крім того, деякі вебсайти неправильно налаштовані на вибір слабшого шифру, навіть якщо клієнт підтримує набагато сильніший. OWASP пропонує посібник з тестування на наявність проблем з SSL/TLS, зокрема слабку підтримку шифрів і неправильну конфігурацію, а також інші ресурси та інструменти.</desc>
	<solution>Фаза: Вимоги
Чітко визначте, які дані чи ресурси є достатньо цінними, щоб їх можна було захистити за допомогою шифрування. Вимагайте, щоб будь-яка передача або зберігання цих даних або ресурсів використовувала добре перевірені алгоритми шифрування.

Фаза: Архітектура та дизайн
Використовуючи моделювання загроз або інші методи, припустіть, що ваші дані можуть бути скомпрометовані через окрему вразливість або слабкість, і визначте, де шифрування буде найбільш ефективним. Переконайтеся, що дані, які, на вашу думку, мають бути приватними, не були випадково розкриті через такі вразливості, як ненадійні дозволи (CWE-732).

Фаза: Архітектура та Дизайн
Переконайтеся, що шифрування інтегровано належним чином в макет системи, включаючи, але не обов'язково обмежуючись:
      Шифрування необхідне для зберігання або передачі особистих даних користувачів системи
      Шифрування необхідне для захисту самої системи від неавторизованого розголошення або втручання 
Визначте окремі потреби та контексти для шифрування:
      Односторонній (тобто лише користувач або одержувач повинен мати ключ). Цього можна досягти за допомогою криптографії з відкритим ключем або інших методів, в яких стороні, що шифрує (тобто програмному забезпеченню), не потрібно мати доступ до закритого ключа.
      Двостороннє (тобто шифрування може автоматично виконуватися від імені користувача, але ключ повинен бути доступним, щоб користувач міг автоматично відновити відкритий текст). Це вимагає зберігання приватного ключа у форматі, який може бути відновлений лише користувачем (або, можливо, операційною системою) у спосіб, який не може бути відновлений іншими.

Фаза: Архітектура та дизайн
Не розробляйте власні криптографічні алгоритми. Вони, швидше за все, будуть піддаватися атакам, які добре зрозумілі криптографам. Методи зворотного проєктування є зрілими. Якщо ваш алгоритм може бути скомпрометований, якщо зловмисники дізнаються, як він працює, тоді він особливо слабкий.

Фаза: Архітектура та дизайн
Виберіть добре перевірений алгоритм, який наразі вважається сильним серед експертів у цій галузі, і виберіть добре протестовані реалізації.
Наприклад, урядові системи США вимагають сертифікації за стандартом FIPS 140-2.
Як і у випадку з усіма криптографічними механізмами, вихідний код повинен бути доступний для аналізу.
Періодично перевіряйте, чи не використовуєте ви застарілу криптографію. Деякі старіші алгоритми, які колись вважалися такими, що потребують мільярд років обчислювального часу, тепер можуть бути зламані за кілька днів або годин. Сюди входять MD4, MD5, SHA1, DES та інші алгоритми, які колись вважалися надійними.

Фаза: Архітектура та дизайн
Розділіть вашу систему на "безпечні" області, де можна чітко окреслити межі довіри. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.

Фази: Впровадження, архітектура та дизайн
Коли ви використовуєте схвалені в індустрії методи, ви повинні використовувати їх правильно. Не економте час, пропускаючи ресурсомісткі етапи (CWE-325). Ці кроки часто необхідні для запобігання поширеним атакам.

Фаза: Впровадження
Використовуйте угоди про імена та сильні типи, щоб легше виявляти, коли використовуються конфіденційні дані. Створюючи структури, об’єкти чи інші складні сутності, якомога більше розділяйте конфіденційні та неконфіденційні дані.
Це полегшує виявлення місць у коді, де використовуються незашифровані дані.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Віддалене включення файлів</alert>
	<desc>Remote File Include (RFI) — це техніка атаки, яка застосовується для використання механізмів «динамічного охоплення файлів» у вебдодатках. Коли вебпрограми приймають введені користувачем дані (URL-адреса, значення параметра тощо) і передають їх у команди охоплення файлів, вебпрограму можуть обманом включити віддалені файли зі шкідливим кодом.

Майже всі структури вебдодатків підтримують охоплення файлів. Охоплення файлів в основному використовується для упакування загального коду в окремі файли, на які пізніше посилаються головні модулі програми. Коли вебдодаток посилається на файл охоплення, код у цьому файлі може бути виконано неявно або явно шляхом виклику певних процедур. Якщо вибір модуля для завантаження базується на елементах запиту HTTP, вебпрограма може бути вразливою до RFI.
Зловмисник може використовувати RFI для:
    * Запуск шкідливого коду на сервері: будь-який код у включених шкідливих файлах запускатиметься сервером. Якщо включення файлу не виконується за допомогою якоїсь оболонки, код в охоплених файлах виконується в контексті користувача сервера. Це може призвести до повного збою системи.
    * Запуск шкідливого коду на клієнтах: шкідливий код зловмисника може маніпулювати вмістом відповіді, надісланої клієнту. Зловмисник може вбудувати шкідливий код у відповідь, яка буде запущена клієнтом (наприклад, JavaScript для викрадення сесійних файлів cookie клієнта).

PHP особливо вразливий до RFI-атак через широке використання «файлових охоплень» у програмуванні PHP і через стандартні конфігурації сервера, які підвищують сприйнятливість до RFI-атак.</desc>
	<solution>Фаза: Архітектура та Дизайн
Якщо набір прийнятних об’єктів, наприклад імен файлів або URL-адрес, обмежений або відомий, створіть зіставлення з набору фіксованих вхідних значень (наприклад, числових ідентифікаторів) на фактичні імена файлів або URL-адреси та відхиліть усі інші вхідні дані.
Наприклад, ідентифікатор 1 може зіставлятися з "inbox.txt", а ідентифікатор 2 – з "profile.txt". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Фаза: Архітектура та Дизайн; Виконання
Запустіть свій код у "в'язниці" або подібному середовищі ізольованого програмного середовища, яке забезпечує суворі межі між обробкою та операційною системою. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.
Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
Будьте обережні, щоб уникнути CWE-243 та інших слабких місць, пов’язаних із в’язницями.
Для PHP транслятор пропонує такі обмеження, як відкритий базовий каталог або безпечний режим, що може ускладнити зловмиснику вихід із програми. Також розгляньте Suhosin, посилене розширення PHP, яке містить різні параметри, які вимикають деякі з найнебезпечніших функцій PHP.

Фаза: Впровадження
Припустимо, що всі введені дані є шкідливими. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.
Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».
Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. Якщо це можливо, дозвольте лише один "." символ у назві файлу, щоб уникнути недоліків, таких як CWE-23, і виключити роздільники каталогів, такі як "/", щоб уникнути CWE-36. Використовуйте дозволений список дозволених розширень файлів, що допоможе уникнути CWE-434.

Фаза: Архітектура та дизайн; Виконання
Якщо це можливо, зберігайте бібліотечні, охоплені та службові файли поза коренем вебдокумента. В іншому випадку зберігайте їх в окремому каталозі та використовуйте можливості керування доступом вебсервера, щоб запобігти зловмисникам безпосередньо запитувати їх. Однією з поширених практик є визначення фіксованої константи в кожній програмі виклику, а потім перевірка існування константи в бібліотеці/файлі включення; якщо константа не існує, це означає, що файл був запрошений безпосередньо, і його можна негайно завершити.
Це значно зменшує ймовірність того, що зловмисник зможе обійти будь-які механізми захисту, які є в базовій програмі, але не у файлах включення. Це також зменшить вашу поверхню атаки.

Фаза: Архітектура та Дизайн; Впровадження
Зрозумійте всі потенційні області, куди ненадійні дані можуть потрапити у ваше програмне забезпечення: параметри чи аргументи, файли cookie, усе, що зчитується з мережі, змінні середовища, зворотні пошуки DNS, результати запитів, заголовки запитів, компоненти URL-адрес, електронна пошта, файли, бази даних і будь-які зовнішні системи, які надають дані програмі. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.
Багато проблем із включенням файлів виникають через те, що програміст припустив, що певні вхідні дані не можна змінити, особливо для файлів cookie та компонентів URL-адреси.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Рядок форматування</alert>
	<desc>Атаки рядків форматування змінюють потік програми, використовуючи функції бібліотеки форматування рядків для доступу до іншого простору пам’яті. Вразливі місця виникають, коли надані користувачем дані використовуються безпосередньо як рядок форматування для певних функцій C/C++ (наприклад, fprintf, printf, sprintf, setproctitle, syslog тощо).

Якщо зловмисник передає рядок форматування, що складається з символів перетворення printf (наприклад, "%f", "%p", "%n" тощо) як значення параметра до вебпрограми, він може:
    * Виконувати довільний код на сервері
    * Читати значення зі стека
    * Спричиняти помилки сегментації / збої програмного забезпечення

Атаки рядку форматування пов’язані з іншими атаками в класифікації загроз: переповнення буфера та переповнення цілого числа. Усі три засновані на своїй здатності маніпулювати пам’яттю або її інтерпретацією таким чином, щоб сприяти досягненню мети зловмисника.</desc>
	<solution>Фаза: Вимоги
Виберіть мову, яка не має цього дефекту.

Фаза: Впровадження
Переконайтеся, що всім функціям рядка форматування передається статичний рядок, який не може контролювати користувач, і що відповідна кількість аргументів також завжди надсилається цій функції. Якщо можливо, використовуйте функції, які не підтримують оператор %n у рядках форматування.
Збірка: Зверніть увагу на попередження компіляторів і компонувальників, оскільки вони можуть попередити вас про неправильне використання.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Переповнення буферу</alert>
	<desc>Переповнення буфера — це недолік, який виникає, коли в блок пам’яті або буфер записується більше даних, ніж призначено для зберігання. Використання переповнення буфера дозволяє зловмиснику змінювати частини адресного простору цільового процесу. Цю здатність можна використовувати для багатьох цілей, зокрема:
    * Контролювати виконання процесу
    * Щоб збити процес
    * Змінити внутрішні змінні

Метою зловмисника майже завжди є контроль за виконанням цільового процесу. Це досягається шляхом визначення покажчика функції в пам'яті, який можна змінити, прямо чи опосередковано, за допомогою переповнення. Коли такий вказівник використовується програмою для керування виконанням програми через інструкцію переходу або виклику, буде використано розташування інструкції, надане зловмисником, таким чином дозволяючи зловмисникові контролювати процес.

У багатьох випадках покажчик функції змінюється, щоб посилатися на місце, де зловмисник розмістив зібрані інструкції для конкретної машини. Ці інструкції зазвичай називають шелл-кодом, оскільки зловмисники часто хочуть створити середовище командного рядка або оболонку в контексті запущеного процесу.

Переповнення буфера найчастіше пов’язане з програмним забезпеченням, написаним на мовах програмування C і C++ через їх широке використання та здатність виконувати прямі маніпуляції з пам’яттю за допомогою звичайних конструкцій програмування. Однак слід підкреслити, що переповнення буфера може існувати в будь-якому середовищі програмування, де дозволено пряме маніпулювання пам’яттю через недоліки в компіляторі, бібліотеках виконання або особливостях самої мови.
</desc>
	<solution>Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Наприклад, багато мов, які здійснюють власне керування пам’яттю, такі як Java і Perl, не підлягають переповненню буфера. Інші мови, такі як Ada та C#, зазвичай забезпечують захист від переповнення, але захист може бути відключений програмістом.
Майте на увазі, що інтерфейс мови до рідного коду все ще може зазнавати переповнень, навіть якщо сама мова теоретично безпечна.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Приклади включають бібліотеку Safe C String Library (SafeStr) від Messier і Viega та бібліотеку Strsafe.h від Microsoft. Ці бібліотеки забезпечують безпечніші версії функцій обробки рядків, схильних до переповнення. Це не повне рішення, оскільки багато переповнень буфера не пов’язані з рядками.

Фаза: Збірка та Компіляція
Запустіть або скомпілюйте програмне забезпечення за допомогою функцій або розширень, які автоматично забезпечують механізм захисту, який пом’якшує або усуває переповнення буфера.
Наприклад, певні компілятори та розширення забезпечують механізми автоматичного виявлення переповнення буфера, вбудовані в скомпільований код. Приклади включають прапор Microsoft Visual Studio /GS, прапор GCC FORTIFY SOURCE Fedora/Red Hat, StackGuard і ProPolice.

Фаза: Впровадження
Розгляньте дотримання наступних правил під час розподілу та керування пам’яттю програми:
      Двічі переконайтеся, що ваш буфер такий великий, як ви вказали.
      Використовуючи функції, які приймають певну кількість байтів для копіювання, наприклад strncpy(), майте на увазі, що якщо розмір буфера призначення дорівнює розміру буфера джерела, він може не завершувати рядок NULL.
      Перевірте межі буфера, якщо ця функція викликається в циклі, і переконайтеся, що вам не загрожує запис за межі виділеного простору.
      Якщо необхідно, обріжте всі вхідні рядки до прийнятної довжини перед тим, як передати їх функціям копіювання та злиття.

Фаза: Виконання
Використовуйте таку функцію, як рандомізація адресного простору (ASLR).

Фаза: Виконання

Використовуйте ЦП і операційну систему, які пропонують Data Execution Protection (NX) або її еквівалент.

Замініть функції необмеженого копіювання на аналогічні функції, які підтримують аргументи довжини, наприклад strcpy на strncpy. Створіть їх, якщо вони недоступні.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Міжсайтовий сценарій</alert>
	<desc>Міжсайтовий сценарій (XSS) — це техніка атаки, яка включає відтворення наданого зловмисником коду в екземпляр вебпереглядача користувача. Екземпляр браузера може бути стандартним клієнтом веббраузера або об’єктом браузера, вбудованим у програмний продукт, такий як браузер у WinAmp, програма для читання RSS або клієнт електронної пошти. Сам код зазвичай пишеться на HTML/JavaScript, але також може поширюватися на VBScript, ActiveX, Java, Flash або будь-яку іншу технологію, що підтримується браузером.
Коли зловмисник змушує браузер користувача виконувати його/її код, код запускатиметься в контексті безпеки (або зоні) вебсайту хостингу. З цим рівнем привілеїв код має можливість читати, змінювати та передавати будь-які конфіденційні дані, доступні браузеру. Користувач із міжсайтовим сценарієм може отримати його/її обліковий запис (викрадення файлів cookie), його вебпереглядач буде перенаправлено в інше місце або, можливо, буде показано шахрайський вміст вебсайту, який вони відвідують. Міжсайтові скриптові атаки по суті підривають довірчі стосунки між користувачем і вебсайтом. Програми, що використовують екземпляри об’єктів браузера, які завантажують вміст із файлової системи, можуть виконувати код у зоні локального комп’ютера, що дозволяє компрометувати систему.

Існує три типи міжсайтових скриптових атак: непостійні, постійні та на основі DOM.
Непостійні атаки та атаки на основі DOM вимагають від користувача або переходу за спеціально створеним посиланням, доповненим шкідливим кодом, або відвідування шкідливої вебсторінки, що містить вебформу, розміщення якої на вразливому сайті спричиняє атаку. Використання шкідливої форми часто відбувається, коли вразливий ресурс приймає лише HTTP POST запити. У такому випадку форма може бути надіслана автоматично, без відома жертви, наприклад, за допомогою JavaScript. Після натискання зловмисного посилання або надсилання зловмисної форми корисне навантаження XSS буде показано назад і буде інтерпретовано браузером користувача та виконано. Інший спосіб надсилання майже довільних запитів (GET і POST) - це використання вбудованого клієнта, наприклад, Adobe Flash.
Постійні атаки відбуваються, коли шкідливий код надсилається на вебсайт, де він зберігається протягом певного часу. Прикладами улюблених цілей зловмисників часто є повідомлення на дошках оголошень, повідомлення вебпошти та програмне забезпечення для вебчатів. Користувачеві, який нічого не підозрює, не потрібно взаємодіяти з будь-яким додатковим сайтом або посиланням, наприклад, сайтом зловмисника або шкідливим посиланням, надісланим електронною поштою, достатньо просто переглянути вебсторінку, що містить код.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Приклади бібліотек і фреймворків, які спрощують створення правильно закодованого виводу, включають бібліотеку Microsoft Anti-XSS, модуль кодування OWASP ESAPI та Apache Wicket.

Фаза: Впровадження; Архітектура та Дизайн
Зрозумійте контекст, у якому використовуватимуться ваші дані, і очікуване кодування. Це особливо важливо під час передачі даних між різними компонентами або під час створення вихідних даних, які можуть містити кілька кодувань одночасно, наприклад вебсторінок або поштових повідомлень, що складаються з кількох частин. Вивчіть усі очікувані протоколи зв’язку та представлення даних, щоб визначити необхідні стратегії кодування.
Для будь-яких даних, які будуть виведені на іншу вебсторінку, особливо будь-яких даних, отриманих із зовнішніх джерел, використовуйте відповідне кодування для всіх символів, які не є алфавітно-цифровими.
Зверніться до шпаргалки щодо запобігання XSS, щоб дізнатися більше про типи кодування та екранування, які потрібні.

Фаза: Архітектура та Дизайн
Для будь-яких перевірок безпеки, які виконуються на стороні клієнта, переконайтеся, що ці перевірки дублюються на стороні сервера, щоб уникнути CWE-602. Зловмисники можуть обійти перевірки на стороні клієнта, змінивши значення після виконання перевірок або змінивши клієнта, щоб повністю видалити перевірки на стороні клієнта. Потім ці змінені значення будуть надіслані на сервер.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Фаза: Впровадження
Для кожної створеної вебсторінки використовуйте та вкажіть кодування символів, наприклад ISO-8859-1 або UTF-8. Якщо кодування не вказано, веббраузер може вибрати інше кодування, вгадавши, яке кодування насправді використовується вебсторінкою. Це може призвести до того, що веббраузер розглядатиме певні послідовності як особливі, відкриваючи клієнта для непомітних атак XSS. Перегляньте CWE-116, щоб дізнатися більше про попередження, пов’язані з кодуванням/екрануванням.

Щоб пом’якшити атаки XSS на сеансовий файл cookie користувача, установіть для файлу cookie сеансу значення HttpOnly. У браузерах, які підтримують функцію HttpOnly (наприклад, новіші версії Internet Explorer і Firefox), цей атрибут може запобігти доступу до файлів cookie сеансу користувача для зловмисних сценаріїв на стороні клієнта, які використовують document.cookie. Це не повне рішення, оскільки HttpOnly підтримується не всіма браузерами. Що ще важливіше, XMLHTTPRequest та інші потужні технології браузера забезпечують доступ для читання заголовків HTTP, включаючи заголовок Set-Cookie, у якому встановлено прапорець HttpOnly.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Переконайтеся, що ви виконуєте перевірку введених даних у чітко визначених інтерфейсах програми. Це допоможе захистити програму, навіть якщо компонент повторно використано або переміщено в інше місце.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Підробка запиту зі сторони сервера</alert>
	<desc>Підробка запиту зі сторони сервера– це атака, яка передбачає примушення жертви надіслати HTTP-запит до цільового призначення без її відома чи наміру, щоб виконати дію від імені жертви. Основна причина полягає в тому, що функція програми використовує передбачувані дії URL/форми повторюваним способом. Зміст атаки полягає в тому, що CSRF використовує довіру користувача до вебсайту. Навпаки, сценарій зі сторони сервера (XSS) використовує довіру користувача до вебсайту. Як і XSS, атаки CSRF не обов’язково є міжсайтовими, але вони можуть бути такими. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.

Атаки CSRF ефективні в ряді ситуацій, зокрема:
    * Жертва має активний сеанс на цільовому сайті.
    * Жертва аутентифікується за допомогою HTTP-автентифікації на цільовому сайті.
    * Жертва знаходиться в тій же локальній мережі, що й цільовий сайт.

CSRF в основному використовувався для виконання дії проти цільового сайту з використанням привілеїв жертви, але нещодавно були виявлені методи розкриття інформації шляхом отримання доступу до відповіді. Ризик розголошення інформації різко зростає, коли цільовий сайт уразливий до XSS, оскільки XSS можна використовувати як платформу для CSRF, дозволяючи атаці діяти в межах політики того самого джерела.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Наприклад, використовуйте пакети захисту від CSRF, такі як OWASP CSRFGuard.

Фаза: Впровадження
Переконайтеся, що у вашій програмі немає проблем зі сценаріями зі сторони сервера, оскільки більшість засобів захисту CSRF можна обійти за допомогою сценарію, керованого зловмисником.

Фаза: Архітектура та Дизайн
Створіть унікальний одноразовий ідентифікатор для кожної форми, помістіть одноразовий ідентифікатор у форму та перевірте його після отримання форми. Переконайтеся, що одноразовий ідентифікатор не є передбачуваним (CWE-330).
Зауважте, що це можна обійти за допомогою XSS.

Визначити особливо небезпечні операції. Коли користувач виконує небезпечну операцію, надішліть окремий запит на підтвердження, щоб переконатися, що користувач мав намір виконати цю операцію.
Зауважте, що це можна обійти за допомогою XSS.

Використовуйте елемент управління сеансами ESAPI.
Цей елемент керування включає компонент для CSRF.

Не використовуйте метод GET для запитів, які ініціюють зміну стану.

Фаза: Впровадження
Перевірте заголовок HTTP Referer, щоб перевірити, чи запит походить з очікуваної сторінки. Це може порушити законні функції, оскільки користувачі або проксі-сервери можуть вимкнути надсилання Referer з міркувань конфіденційності.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Відмова в обслуговуванні</alert>
	<desc>Відмова в обслуговуванні (DoS) - це техніка атаки з метою перешкодити вебсайту обслуговувати нормальну діяльність користувачів. DoS-атаки, які зазвичай легко застосовуються на мережевому рівні, також можливі на рівні застосунків. Ці зловмисні атаки можуть бути успішними завдяки позбавленню системи критичних ресурсів, використанню вразливостей або зловживанню функціоналом.

Часто DoS-атаки намагаються поглинути всі доступні системні ресурси вебсайту, такі як: ЦП, пам'ять, дисковий простір тощо. Коли будь-який з цих критично важливих ресурсів досягає повного використання, вебсайт, як правило, стає недоступним.

Оскільки сучасні середовища вебзастосунків включають вебсервер, сервер баз даних і сервер аутентифікації, DoS-атаки на рівні застосунків можуть бути спрямовані на кожен з цих незалежних компонентів. На відміну від DoS на мережевому рівні, де потрібна велика кількість спроб з'єднання, DoS на рівні застосунків є набагато простішим завданням.</desc>
	<solution>Фаза: Архітектура та дизайн

Розробіть механізми дроселювання в архітектуру системи. Найкращий захист - обмежити кількість ресурсів, які може витратити несанкціонований користувач. Надійна модель автентифікації та контролю доступу допоможе в першу чергу запобігти таким атакам. Застосунок для входу повинен бути максимально захищений від DoS-атак. Обмеження доступу до бази даних, можливо, шляхом кешування наборів результатів, може допомогти мінімізувати витрачені ресурси. Щоб ще більше обмежити потенціал DoS-атаки, розгляньте можливість відстеження швидкості запитів, отриманих від користувачів, і блокування запитів, які перевищують певний поріг швидкості.

Пом'якшення наслідків атак на вичерпання ресурсів вимагає, щоб цільова система або
      розпізнала атаку і заборонила користувачеві подальший доступ на певний проміжок часу, або
      рівномірно гальмувала всі запити, щоб ускладнити споживання ресурсів швидше, ніж вони можуть бути знову звільнені. 

Перше з цих рішень є проблемою саме по собі, оскільки воно може дозволити зловмисникам запобігти використанню системи певним дійсним користувачем. Якщо зловмисник видає себе за дійсного користувача, він може заборонити користувачеві доступ до відповідного сервера.

Друге рішення просто важко ефективно впровадити - і навіть якщо це зроблено належним чином, воно не забезпечує повного розв'язання проблеми. Це просто робить атаку більш ресурсомісткою для зловмисника.

Переконайтеся, що протоколи мають конкретні обмеження щодо масштабу.

Фаза: Впровадження
Переконайтеся, що всі збої в розподілі ресурсів переводять систему в безпечний стан.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Атака прямим добором облікових даних для входу</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Найпоширенішим типом атаки прямого добору у вебзастосунках є атака на облікові дані для входу в систему. Оскільки користувачам потрібно запам'ятовувати паролі, вони часто вибирають для паролів слова або фрази, які легко запам'ятовуються, що робить атаку повного перебору корисною з використанням словника. Таку атаку зі спробою входу в систему з використанням великого списку слів і фраз як потенційних паролів, часто називають "атакою за списком слів" або "атакою за словником". Спроби паролів можуть також включати варіації слів, які часто зустрічаються в паролях, наприклад, створені шляхом заміни "o" на "0" та "i" на "1", а також особисту інформацію, зокрема імена членів сім'ї, дати народження та номери телефонів.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Ідентифікатори сеансів перебору</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Оскільки HTTP є протоколом без збереження стану, для підтримки стану вебпрограми необхідно переконатися, що ідентифікатор сеансу надсилається браузером із кожним запитом. Ідентифікатор сеансу найчастіше зберігається в HTTP-файлі cookie або URL-адресі. Використовуючи атаку прямого добору, зловмисник може вгадати ідентифікатор сеансу іншого користувача. Це може призвести до того, що зловмисник видаватиме себе за користувача, отримуватиме особисту інформацію та виконуватиме дії від імені користувача.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Атака через тиск на каталоги та файли</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Коли файли знаходяться в каталогах, які обслуговуються вебсервером, але ніде не пов'язані між собою, для доступу до них потрібно знати ім'я файлу. У деяких випадках ці файли були залишені помилково: наприклад, файл резервної копії, автоматично створений при редагуванні файлу, або залишки старішої версії вебзастосунку. В інших випадках файли навмисно залишаються незв’язаними як механізм «безпеки через невідомість», що дозволяє отримати доступ до них лише людям, які знають імена файлів.

Атака повного перебору намагається знайти незв'язаний файл, намагаючись отримати доступ до великої кількості файлів. Список можливих імен файлів може бути взятий зі списку відомих потенційних файлів або на основі варіантів видимих файлів на вебсайті. Додаткову інформацію про каталоги та файли підбіркою можна знайти у розділі пов’язана вразливість, передбачуване розташування ресурсу.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Атака через перевірку інформації кредитної картки</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Для здійснення покупок в Інтернеті за допомогою вкрадених кредитних карток зазвичай потрібна інформація на додаток до номера кредитної картки, найчастіше CVV/SCS та/або термін дії. Шахрай може володіти номером викраденої кредитної картки без додаткової інформації. Наприклад, CVV або CSC не друкується на картці та не зберігається на магнітній смузі, тому він не може бути зчитаний механічними або магнітними пристроями для зчитування кредитних карток.

Для того, щоб заповнити відсутню інформацію, хакер може вгадати відсутню інформацію за допомогою методу «грубої сили», перебираючи всі можливі значення.
    * Вгадування CVV або CSC потребує лише 1000 або 10000 спроб, оскільки номер складається лише з 3 або 4 цифр, залежно від типу картки.
    * Щоб вгадати термін придатності, потрібно лише кілька десятків спроб.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Підміна вмісту</alert>
	<desc>Підміна вмісту - це метод атаки, який дозволяє зловмиснику впровадити шкідливе корисне навантаження, яке потім видається за легальний вміст вебзастосунку.
 
Підміна лише текстового вмісту
Поширеним підходом до динамічного створення сторінок є передача тіла сторінки або його частин через значення рядка запиту. Такий підхід поширений на сторінках з помилками або на сайтах, що надають статті чи новини. Вміст, указаний у цьому параметрі, пізніше показується на сторінці, щоб надати вміст для сторінки.
 
Імітація показаного вмісту розмітки
Деякі вебсторінки обслуговуються за допомогою динамічно побудованих джерел вмісту HTML. Наприклад, вихідне розташування кадру <frame src="http://foo.example/file.html"/>) можна вказати значенням параметра URL-адреси. (http://foo.example/page?frame_src=http://foo.example/file.html). Зловмисник може замінити значення параметра "frame_src" на "frame_src=http://attacker.example/spoof.html". На відміну від перенаправлячів, коли кінцева вебсторінка обслуговується, рядок розташування вебпереглядача видимо залишається під очікуваним доменом користувача (foo.example), але сторонні дані (attacker.example) прикриваються законним вмістом.

Спеціально створені посилання можуть надсилатися користувачеві електронною поштою, миттєвими повідомленнями, залишатися на дошках оголошень або нав’язуватися користувачам за допомогою міжсайтової атаки. Якщо зловмисник змусить користувача відвідати вебсторінку, позначену його шкідливою URL-адресою, користувач вважатиме, що він переглядає автентичний контент з одного місця, хоча це не так. Користувачі неявно довірятимуть підробленому контенту, оскільки в рядку місцезнаходження браузера відображається http://foo.example, тоді як насправді HTML-фрейм, що лежить в основі, посилається на http://attacker.example.

Ця атака використовує довірчі стосунки, встановлені між користувачем і вебсайтом. Цей метод використовувався для створення фальшивих вебсторінок, включаючи форми для входу в систему, спотворення, фальшиві пресрелізи тощо.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Витік інформації</alert>
	<desc>Витік інформації - це вразливість програми, коли програма розкриває конфіденційні дані, такі як технічні деталі вебзастосунку, середовище або дані користувача. Конфіденційні дані можуть бути використані зловмисником для експлуатації цільового вебзастосунку, його хостингової мережі або користувачів. Тому витік конфіденційних даних слід обмежувати або запобігати, коли це можливо. Витік інформації, у своїй найпоширенішій формі, є результатом однієї або кількох із наведених нижче умов: нездатність видалити коментарі HTML/сценарію, що містять конфіденційну інформацію, неправильні конфігурації програми чи сервера або відмінності у відповідях сторінки щодо дійсних і недійсних даних .

Неможливість очистити коментарі HTML/сценарію перед надсиланням у робоче середовище може призвести до витоку конфіденційної контекстної інформації, такої як структура каталогу сервера, структура запиту SQL і інформація про внутрішню мережу. Часто розробник залишає коментарі в коді HTML та/або сценарію, щоб полегшити процес налагодження чи інтеграції на етапі підготовки до виробництва. Хоча немає ніякої шкоди в тому, щоб дозволити розробникам включати вбудовані коментарі до контенту, який вони розробляють, всі ці коментарі слід видаляти перед публічним випуском контенту.

Номери версій програмного забезпечення та докладні повідомлення про помилки (наприклад, номери версій ASP.NET) є прикладами неправильних конфігурацій сервера. Ця інформація корисна для зловмисника, оскільки надає детальне уявлення про фреймворк, мови або вбудовані функції, що використовуються вебзастосунком. Більшість конфігурацій серверів за замовчуванням надають номери версій програмного забезпечення та докладні повідомлення про помилки для налагодження та усунення несправностей. Можна внести зміни до конфігурації, щоб вимкнути ці функції, запобігаючи відображенню цієї інформації.

Сторінки, які надають різні відповіді залежно від достовірності даних, також можуть призвести до витоку інформації; зокрема, коли дані, які вважаються конфіденційними, стають доступними в результаті дизайну вебзастосунку. Приклади конфіденційних даних включають (але не обмежуються ними): номери рахунків, ідентифікатори користувачів (номер водійських прав, номер паспорта, номери соціального страхування тощо) та інформацію про користувачів (паролі, сесії, адреси). Витік інформації в цьому контексті стосується витоку ключових даних користувача, які вважаються конфіденційними або секретними, і які не повинні бути доступними для огляду навіть самому користувачеві. Номери кредитних карток та інша суворо регульована інформація є яскравими прикладами даних користувачів, які потребують додаткового захисту від витоку, навіть за наявності належного шифрування та контролю доступу.</desc>
	<solution>Розділіть вашу систему на "безпечні" зони, де можна чітко окреслити межі довіри. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Неправильна конфігурація сервера</alert>
	<desc>Атаки на неправильну конфігурацію сервера використовують слабкі місця в конфігурації вебсерверів та серверів застосунків. Багато серверів постачаються з непотрібними файлами за замовчуванням і зразками, включаючи програми, файли конфігурації, сценарії та вебсторінки. У них також можуть бути ввімкнені непотрібні служби, такі як керування контентом і функції віддаленого адміністрування. Налагоджувальні функції можуть бути увімкнені або адміністративні функції можуть бути доступні анонімним користувачам. Ці функції можуть надати хакеру можливість обійти методи автентифікації та отримати доступ до конфіденційної інформації, можливо, з підвищеними привілеями.

Сервери можуть містити відомі облікові записи та паролі за замовчуванням. Якщо не вдасться повністю заблокувати або посилити захист сервера, можуть залишитися неправильно встановлені дозволи на файли та каталоги. Неправильно налаштовані сертифікати SSL і параметри шифрування, використання сертифікатів за замовчуванням і неправильна реалізація автентифікації за допомогою зовнішніх систем можуть поставити під загрозу конфіденційність інформації.

Докладні та інформативні повідомлення про помилки можуть призвести до витоку даних, а виявлена інформація може бути використана для формулювання наступного рівня атаки. Неправильні конфігурації в програмному забезпеченні сервера можуть дозволити індексування каталогів і атаки обходу шляху.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Неправильна конфігурація застосунку</alert>
	<desc>Атаки на неправильну конфігурацію сервера використовують слабкі місця в конфігурації вебсерверів та серверів застосунків. Багато програм постачаються з непотрібними та небезпечними функціями, такими як функції налагодження та контролю якості, увімкнені за замовчуванням. Ці функції можуть надати хакеру можливість обійти методи автентифікації та отримати доступ до конфіденційної інформації, можливо, з підвищеними привілеями.

Подібним чином інсталяції за замовчуванням можуть включати добре відомі імена користувачів і паролі, жорстко закодовані облікові записи для обходу системи, спеціальні механізми доступу та неправильно встановлені дозволи для файлів, доступних через вебсервери. Зразки за замовчуванням можуть бути доступні у виробничих середовищах. Конфігураційні файли застосунків, які не заблоковані належним чином, можуть містити чіткі текстові рядки з'єднання з базою даних, а налаштування за замовчуванням у конфігураційних файлах можуть бути встановлені без врахування вимог безпеки. Всі ці неправильні конфігурації можуть призвести до несанкціонованого доступу до конфіденційної інформації.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Індексування каталогів</alert>
	<desc>Автоматичний список або індексація каталогів - це функція вебсервера, яка перераховує всі файли в запитуваному каталозі, якщо звичайний базовий файл (index.html/home.html/default.htm/default.asp/default.aspx/index.php) відсутній. Коли користувач запитує головну сторінку вебсайту, він зазвичай вводить URL-адресу, таку як http://www.example.com/directory1/, використовуючи доменне ім'я і не вказуючи конкретний файл. Вебсервер обробляє цей запит, шукає в кореневому каталозі документа ім'я файлу за замовчуванням і надсилає цю сторінку клієнту. Якщо ця сторінка відсутня, вебсервер динамічно видасть список каталогів і надішле його клієнту. По суті, це еквівалентно виконанню команди «ls» (Unix) або «dir» (Windows) у цьому каталозі та показу результатів у формі HTML. З точки зору атак і контрзаходів, важливо розуміти, що небажані списки каталогів можуть бути створені через уразливості програмного забезпечення (розглянуті в розділі прикладів нижче) в поєднанні з певним вебзапитом.</desc>
	<solution>Рекомендації включають обмеження доступу до важливих каталогів або файлів шляхом прийняття вимоги про необхідність знати як для документа, так і для кореня сервера, а також вимкнення таких функцій, як автоматичні списки каталогів, які можуть розкрити приватні файли та надати інформацію, що може бути використана зловмисником при підготовці або проведенні атаки.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Неналежні дозволи файлової системи</alert>
	<desc>Неналежні дозволи файлової системи є загрозою для конфіденційності, цілісності та доступності вебпрограми. Проблема виникає, коли для файлів, тек і символічних посилань встановлено неправильні дозволи файлової системи. Якщо встановлено неправильні дозволи, зловмисник може отримати доступ до обмежених файлів або каталогів і змінити або видалити їхній вміст. Наприклад, якщо анонімний обліковий запис користувача має дозвіл на запис до файлу, то зловмисник може змінити вміст файлу, впливаючи на вебзастосунок у небажаний спосіб. Зловмисник також може використати невідповідні символічні посилання, щоб підвищити свої привілеї та/або отримати доступ до неавторизованих файлів; наприклад, символічне посилання, яке вказує на каталог за межами кореневої вебсторінки.</desc>
	<solution>Дуже ретельно керуйте налаштуванням, керуванням і обробкою дозволів. Явно керуйте зонами довіри в програмному забезпеченні.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Облікові дані та прогноз сеансу</alert>
	<desc>Прогноз облікових даних/сеансу – це метод викрадення або видавання себе за користувача вебсайту. Виведення або вгадування унікального значення, яке ідентифікує конкретний сеанс або користувача, що виконує атаку. Також відоме як викрадення сеансу, наслідки можуть дозволити зловмисникам надсилати запити вебсайту з привілеями скомпрометованого користувача.

Багато вебсайтів розроблено для автентифікації та відстеження користувача під час першого встановлення зв’язку. Для цього користувачі повинні підтвердити свою особу на вебсайті, як правило, шляхом надання комбінації імені користувача та пароля (облікових даних). Замість того, щоб передавати ці конфіденційні облікові дані туди-сюди з кожною транзакцією, вебсайти генеруватимуть унікальний «ідентифікатор сеансу», щоб ідентифікувати сеанс користувача як автентифікований. Подальше спілкування між користувачем і вебсайтом позначається ідентифікатором сеансу як «доказ» автентифікованого сеансу. Якщо зловмисник може передбачити або вгадати ідентифікатор сеансу іншого користувача, можлива шахрайська діяльність.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference/>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL впровадження</alert>
	<desc>SQL-ін'єкція - це метод атаки, який використовується для експлуатації додатків, що створюють SQL-запити на основі введених користувачем даних. У разі успіху зловмисник може змінити логіку інструкцій SQL, які виконуються для бази даних.

Структурована мова запитів (SQL) — це спеціалізована мова програмування для надсилання запитів до баз даних. Мова програмування SQL є як стандартом ANSI, так і стандартом ISO, хоча багато продуктів баз даних, що підтримують SQL, роблять це за допомогою власних розширень стандартної мови. Застосунки часто використовують дані, надані користувачем, для створення операторів SQL. Якщо програма не може правильно побудувати оператори SQL, зловмисник може змінити структуру операторів і виконати незаплановані та потенційно шкідливі команди. Коли такі команди виконуються, вони виконуються у контексті користувача, вказаного програмою, що виконує оператор. Ця можливість дозволяє зловмисникам отримати контроль над усіма ресурсами бази даних, доступними цьому користувачеві, зокрема можливість виконувати команди в системі хостингу.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Наприклад, розгляньте можливість використання рівнів стійкості, таких як Hibernate або Enterprise Java Beans, які можуть забезпечити суттєвий захист від SQL-впроваджень за умови належного використання.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Обробляйте запити SQL за допомогою підготовлених операторів, параметризованих запитів або збережених процедур. Ці функції повинні приймати параметри або змінні та підтримувати жорстку типізацію. Не створюйте динамічно та не виконуйте рядки запитів у цих функціях за допомогою "exec" або подібної функції, оскільки ви можете знову запровадити можливість впровадження SQL.

Запускайте свій код з найнижчими привілеями, які потрібні для виконання необхідних завдань. Якщо можливо, створюйте ізольовані облікові записи з обмеженими правами, які використовуються лише для однієї задачі. Таким чином, успішна атака не відразу надасть зловмиснику доступ до решти програмного забезпечення або його середовища. Наприклад, програми баз даних рідко потребують запуску від імені адміністратора бази даних, особливо під час повсякденних операцій.

Зокрема, дотримуйтесь принципу найменших привілеїв під час створення облікових записів користувачів до бази даних SQL. Користувачі бази даних повинні мати лише мінімальні привілеї, необхідні для використання свого облікового запису. Якщо вимоги системи вказують на те, що користувач може читати та змінювати власні дані, обмежте його права, щоб він не міг читати або записувати чужі дані. Використовуйте найсуворіші дозволи на всі об'єкти бази даних, наприклад, тільки на виконання для збережених процедур.

Фаза: Впровадження
Якщо вам потрібно використовувати динамічно створені рядки запиту або команди, всупереч ризику, належним чином наведіть аргументи та виключіть будь-які спеціальні символи в цих аргументах. Найбільш консервативний підхід полягає в тому, щоб уникнути або відфільтрувати всі символи, які не проходять надзвичайно суворий список дозволених (наприклад, усе, що не є буквено-цифровим або пробілом). Якщо деякі спеціальні символи все ще потрібні, наприклад пробіл, візьміть кожен аргумент у лапки після етапу екранування/фільтрування. Будьте обережні з введенням аргументів (CWE-88).

Замість створення власного впровадження такі функції можуть бути доступні в базі даних або мовою програмування. Наприклад, пакет СУБД Oracle ASSERT може перевіряти або примусово контролювати наявність у параметрів певних властивостей, які роблять їх менш уразливими до впровадження SQL. Для MySQL функція mysql real escape string() API доступна як на C, так і на PHP.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Під час створення рядків запиту SQL використовуйте суворі списки дозволів, які обмежують набір символів на основі очікуваного значення параметра в запиті. Це опосередковано обмежить область атаки, але цей метод менш важливий, ніж правильне кодування виводу та екранування.

Зауважте, що правильне кодування виводу, екранування та цитування є найефективнішим рішенням для запобігання впровадження SQL, хоча перевірка введення може забезпечити певний поглиблений захист. Це пов’язано з тим, що він фактично обмежує те, що показуватиметься у виводі. Перевірка введених даних не завжди запобігатиме впровадженню SQL, особливо якщо від вас вимагається підтримка текстових полів довільної форми, які можуть містити довільні символи. Наприклад, ім'я "О'Рейлі", швидше за все, пройде етап перевірки, оскільки це поширене прізвище в англійській мові. Однак його не можна безпосередньо вставити в базу даних, оскільки він містить символ апостроф "'", який потрібно екранувати або обробити іншим чином. У цьому випадку видалення апострофа може зменшити ризик впровадження SQL, але це призведе до неправильної поведінки, оскільки буде записане неправильне ім’я.

Якщо можливо, найбезпечніше повністю заборонити метасимволи, а не екранувати їх. Це забезпечить певний глибокий захист. Після внесення даних до бази даних подальші процеси можуть нехтувати екрануванням метасимволів перед використанням, і ви можете не мати контролю над цими процесами.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference/>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Неправильна обробка введення</alert>
	<desc>Неправильна обробка введених даних є одним із найпоширеніших недоліків, виявлених у сьогоднішніх програмах. Погана обробка вхідних даних є основною причиною критичних вразливостей, які існують в системах та застосунках.
	
Зазвичай термін «обробка вхідних даних» використовується для опису таких функцій, як перевірка, очищення, фільтрація, кодування та/або декодування вхідних даних. Програми отримують вхідні дані з різних джерел, зокрема від користувачів, програмних агентів (браузерів) і мережевих/периферійних пристроїв. У випадку вебдодатків вхідні дані можна передавати в різних форматах (пари імен значення, JSON, SOAP тощо...) і отримувати через рядки запиту URL-адреси, дані POST, заголовки HTTP, файли cookie тощо... Вхідні дані не з вебдодатків можна отримати через змінні програми, змінні середовища, реєстр, файли конфігурації тощо... Незалежно від формату даних або джерела/місцезнаходження вхідних даних, усі введені дані слід вважати ненадійними та потенційно шкідливими. Програми, які обробляють ненадійний вхід, можуть стати вразливими до таких атак, як переповнення буфера, впровадження SQL, керування ОС, відмова в обслуговуванні.

Одним із ключових аспектів обробки вхідних даних є перевірка того, що вхідні дані відповідають певним критеріям. Для належної перевірки важливо визначити форму та тип даних, які є прийнятними та очікуваними для програми. Для точного визначення обмежень необхідне визначення очікуваного формату і використання кожного екземпляра ненадійних даних. 

Перевірка може включати перевірку безпеки типу та правильного синтаксису. Введені рядки можна перевірити на довжину (мінімальна та максимальна кількість символів) і перевірити набір символів, тоді як типи числових вводів, як-от цілі чи десяткові числа, можна перевірити на допустиму верхню та нижню межу значень. При поєднанні вхідних даних із кількох джерел перевірку слід виконувати під час злиття, а не лише щодо окремих елементів даних. Ця практика допомагає уникнути ситуацій, коли перевірка вхідних даних може бути успішною, якщо виконується на окремих елементах даних, але не вдається, якщо виконується на комбінованому наборі з усіх джерел.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Зловмисники можуть обійти перевірки на стороні клієнта, змінивши значення після виконання перевірок або змінивши клієнта, щоб повністю видалити перевірки на стороні клієнта. Потім ці змінені значення будуть надіслані на сервер.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато способів кодування одного і того ж символу, тому ви, швидше за все, пропустите деякі варіанти.

Якщо ваш застосунок об'єднує дані з декількох джерел, виконайте перевірку після того, як джерела будуть об'єднані. Окремі елементи даних можуть пройти етап перевірки, але після об'єднання порушувати встановлені обмеження.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Фаза: Реалізація

Будьте особливо уважні до перевірки ваших даних, коли викликаєте код, який перетинає мовні кордони, наприклад, з інтерпретованої мови на рідну. Це може створити несподівану взаємодію між мовними кордонами. Переконайтеся, що ви не порушуєте жодних очікувань мови, якою ви спілкуєтеся. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Такі помилки можна використовувати для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки. Використовуйте такі бібліотеки, як елемент керування канонізацією OWASP ESAPI.

Повторюйте канонізацію доти, доки ваші дані не перестануть змінюватися. Це дозволить уникнути подвійного декодування та подібних сценаріїв, але може ненавмисно змінити вхідні дані, які можуть містити належним чином закодований небезпечний вміст.

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно вказуйте кодування, яке ви використовуєте, якщо це дозволяє протокол.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Недостатня антиавтоматизація</alert>
	<desc>Недостатня антиавтоматизація виникає, коли вебзастосунок дозволяє зловмиснику автоматизувати процес, який спочатку був розроблений для виконання лише вручну, тобто людиною-користувачем Інтернету.

Функціональність веб-додатку, яка часто стає ціллю для автоматизованих атак, може включати в себе:
    * Форми входу в додаток - зловмисники можуть автоматизувати запити на вхід в систему методом грубої сили, намагаючись вгадати облікові дані користувача
    * Форми реєстрації сервісів - зловмисники можуть автоматично створювати тисячі нових облікових записів
    * Форми електронної пошти - зловмисники можуть використовувати форми електронної пошти як ретранслятори спаму або для переповнення поштової скриньки певного користувача
    * Обслуговування акаунтів - зловмисники можуть виконувати масові DoS-атаки на додаток, засипаючи його численними запитами на відключення або видалення облікових записів користувачів
    * Форми відомостей про обліковий запис - зловмисники можуть виконувати масові спроби збору персональної інформації користувачів з веб-додатку
    * Форми коментування / форми відправки вмісту - можуть бути використані для спаму блогів, веб-форумів та дошок оголошень шляхом автоматичної відправки вмісту, наприклад, спаму або навіть веб-шкідливого програмного забезпечення.
    * Форми, прив'язані до запитів до бази даних SQL - вони можуть бути використані для проведення атаки на відмову в обслуговуванні програми. Атака виконується шляхом надсилання численних інтенсивних SQL-запитів за короткий проміжок часу, таким чином відмовляючи реальним користувачам в обслуговуванні.
    * eShopping або eCommerce - застосунки для електронних магазинів та електронної комерції, які не обмежують коло покупців лише людьми, можуть бути використані для купівлі бажаних товарів у великих кількостях, наприклад, квитків на спортивні заходи. These are later sold by scalpers for higher prices.
    * Онлайн-опитування - опитування та інші види систем онлайн-голосування можуть бути автоматично підтасовані на користь певного вибору.
    * Розсилка SMS-повідомлень через Інтернет - зловмисники можуть використовувати системи розсилки SMS-повідомлень для розсилання спаму користувачам мобільних телефонів
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Improper Output Handling</alert>
	<desc>Обробка виводу - це те, як додаток генерує вихідні дані.  Якщо додаток має неправильну обробку виводу, вихідні дані можуть бути використані, що призведе до вразливих місць і дій, які не були заплановані розробником додатку.  У багатьох випадках така ненавмисна інтерпретація класифікується як одна або декілька форм вразливих місць критичних додатків.

Будь-яке розташування, де дані залишають межі додатку, може бути наслідком неправильної обробки вихідних даних.  Межі додатку існують там, де дані залишають один контекст і потрапляють в інший.  Сюди входять додатки, що передають дані іншим програмам через веб-сервіси, сокети, командний рядок, змінні середовища тощо...  Сюди також входить передача даних між рівнями в архітектурі додатку, такими як база даних, сервер каталогів, HTML/JavaScript інтерпретатор (браузер) або операційна система.  Більш детально про те, де може виникати неправильна обробка виводу, можна дізнатися в розділі нижче під назвою "Загальні місця виводу даних".

Неправильна обробка виводу може набувати різних форм у додатку.  Ці форми можна класифікувати на: помилки протоколу, помилки додатку та помилки, пов'язані зі споживачем даних.  Помилки протоколу включають відсутність або неправильне кодування вихідних даних, екранування та виведення недійсних даних.  Помилки додатку включають логічні помилки, такі як виведення неправильних даних або передача шкідливого вмісту без фільтрації.  Якщо додаток не відрізняє належним чином легітимний вміст від нелегітимного або не обходить відомі вразливі місця споживача даних, це може призвести до зловживань з боку споживача даних, спричинених неправильною обробкою вихідних даних.

Додаток, який не надає дані в правильному контексті, може дозволити зловмиснику зловживати споживачем даних.  Це може призвести до певних загроз, зазначених у Класифікації загроз WASC, зокрема підміни вмісту, міжсайтового скриптингу, розділення HTTP-відповідей, контрабанди HTTP-відповідей, LDAP введення, керування ОС, обхід маршрутизації, зловживання масивами SOAP, перенаправлення URL-адреси, XML введення, XQuery введення, XPath введення, впровадження поштових команд, нульового введення та SQL-введення.

Належна обробка вихідних даних запобігає неочікуваній або ненавмисній інтерпретації даних споживачем.  Щоб досягти цієї мети, розробники повинні розуміти модель даних додатку, як дані будуть використовуватися іншими частинами додатку і як вони будуть запропоновані користувачеві.  Методи забезпечення належної обробки вихідних даних включають, але не обмежуються фільтрацією та санітарною обробкою даних (більш детально про санітарну обробку та фільтрацію вихідних даних можна знайти у відповідних розділах нижче).  Однак непослідовне використання обраних методів обробки вихідних даних може фактично збільшити ризик неправильної обробки вихідних даних, якщо вихідні дані будуть проігноровані або залишені без обробки.  Для забезпечення "глибокого захисту" розробники повинні припускати, що всі дані в додатку є ненадійними, при виборі відповідних стратегій обробки виводу.

Хоча належна обробка вихідних даних може приймати різні форми, додаток не може бути безпечним, якщо він не захищає від ненавмисних інтерпретацій з боку споживача даних. Ця основна вимога необхідна для того, щоб додаток міг безпечно обробляти операції виводу.</desc>
	<solution>Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

Наприклад, розгляньте можливість використання елемента керування ESAPI Encoding або подібного інструменту, бібліотеки чи фреймворку. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

Або ж використовуйте вбудовані функції, але розгляньте можливість використання оболонок на випадок, якщо в цих функціях буде виявлено вразливість.

Якщо це можливо, використовуйте структуровані механізми, які автоматично забезпечують розділення даних і коду. Ці механізми можуть забезпечити відповідне цитування, кодування та перевірку автоматично, замість того, щоб покладатися на розробника, який має забезпечувати цю можливість у кожній точці, де генерується результат.

Наприклад, збережені процедури можуть забезпечити дотримання структури запитів до бази даних і зменшити ймовірність SQL-введення.

Зрозумійте, в якому контексті будуть використовуватися ваші дані і яке кодування очікується. Це особливо важливо при передачі даних між різними компонентами або при створенні вихідних даних, які можуть містити кілька кодувань одночасно, наприклад, веб-сторінки або поштові повідомлення, що складаються з кількох частин. Вивчіть всі очікувані протоколи зв'язку та представлення даних, щоб визначити необхідні стратегії кодування.

У деяких випадках перевірка вхідних даних може бути важливою стратегією, коли вихідне кодування не є повним рішенням. Наприклад, ви можете надавати один і той самий вихідний файл, який буде оброблятися кількома споживачами, що використовують різні кодування або представлення. В інших випадках вам може знадобитися дозволити користувацькому введенні містити контрольну інформацію, наприклад, обмежені HTML-теги, які підтримують форматування у Вікі або дошці оголошень. Коли потрібно виконати цей тип вимог, використовуйте дуже суворий список дозволів, щоб обмежити, які контрольні послідовності можна використовувати. Перевірте, чи отримана синтаксична структура відповідає вашим очікуванням. Для решти даних використовуйте ваші звичайні методи кодування.

Використовуйте перевірку вхідних даних як глибинну міру захисту, щоб зменшити ймовірність помилок вихідного кодування (див. CWE-20).

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно встановлюйте кодування, яке ви використовуєте, якщо це дозволяє протокол.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference/>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML введення</alert>
	<desc>XML-введення - це метод атаки, який використовується для керування або компрометації логіки XML-додатку або сервісу. Введення в XML-повідомлення ненавмисного вмісту та/або структур може змінити логіку роботи додатку. Крім того, XML-введення може призвести до вставки шкідливого вмісту в отримане повідомлення/документ.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference/>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>Поділ HTTP-запитів</alert>
	<desc>Поділ HTTP запитів - це атака, яка дозволяє змусити браузер надсилати довільні HTTP-запити, що призводить до XSS-атак та отруєння кешу браузера. Суть атаки полягає в здатності зловмисника, після того, як жертва (браузер) змушена завантажити шкідливу HTML-сторінку зловмисника, керувати однією з функцій браузера, щоб замість одного HTTP-запиту відправити 2 HTTP-запити. Використовуються два таких механізми: об'єкт XmlHttpRequest (скорочено XHR) і механізм автентифікації HTTP-дайджесту. Щоб ця атака спрацювала, браузер повинен використовувати прямий проксі HTTP (не всі вони "підтримують" цю атаку), або атака повинна бути проведена проти хоста, розташованого на одній IP-адресі (з точки зору браузера) з машиною зловмисника.</desc>
	<solution>Не використовуйте CRLF як спеціальну послідовність.

Належним чином фільтрувати або цитувати CRLF-послідовності у вхідних даних, контрольованих користувачем.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>Поділ HTTP-запитів</alert>
	<desc>В атаці поділу HTTP-відповіді завжди беруть участь 3 сторони (як мінімум):
    * Веб-сервер, який має дірку в безпеці, що дозволяє поділ HTTP-відповіді
    * Ціль - об'єкт, який взаємодіє з веб-сервером, можливо, від імені зловмисника. Зазвичай це кеш-сервер (прямий/зворотний проксі) або браузер (можливо, з кешем браузера).
    * Зловмисник - ініціює атаку

Суть поділу HTTP-відповіді полягає в тому, що зловмисник може надіслати один HTTP-запит, який змушує веб-сервер сформувати вихідний потік, який потім інтерпретується ціллю як дві HTTP-відповіді замість однієї відповіді, як у звичайному випадку. Перша реакція може частково контролюватися зловмисником, але це не так важливо. Важливо те, що зловмисник повністю контролює форму другої відповіді від рядка стану HTTP до останнього байта тіла HTTP-відповіді. Як тільки це стає можливим, зловмисник реалізує атаку, надсилаючи два запити через ціль. Перший викликає дві відповіді від веб-сервера, а другий запит, як правило, надсилається до якогось "невинного" ресурсу на веб-сервері. Однак, на другий запит зловмисник отримає другу HTTP-відповідь, яка повністю контролюється зловмисником. Таким чином, зловмисник обманом змушує ціль повірити, що певний ресурс на веб-сервері (позначений другим запитом) є HTTP-відповіддю сервера (вміст сервера), тоді як насправді це певні дані, які зловмисник підробляє через веб-сервер - це і є друга відповідь.

Атаки поділу HTTP-відповіді  відбуваються, коли серверний скрипт вбудовує дані користувача в заголовки HTTP-відповідей. Зазвичай це відбувається, коли скрипт вбудовує дані користувача в URL-адресу відповіді перенаправлення (код стану HTTP 3xx) або коли скрипт вбудовує дані користувача в значення або ім'я файлу cookie, коли відповідь встановлює файл cookie.</desc>
	<solution>Конструюйте HTTP-заголовки дуже уважно, уникаючи використання неперевірених вхідних даних.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>Контрабанда HTTP-запиту</alert>
	<desc>Контрабанда HTTP-запиту - це метод атаки, яка використовує розбіжності в розборі невідповідних RFC HTTP-запитів між двома HTTP-пристроями (як правило, зовнішнім проксі-сервером або брандмауером з підтримкою HTTP і внутрішнім веб-сервером), щоб передати запит на другий пристрій "через" перший пристрій. Ця техніка дозволяє зловмиснику надсилати один набір запитів на другий пристрій, в той час як перший пристрій бачить інший набір запитів. У свою чергу, це полегшує кілька можливих експлойтів, таких як часткове отруєння кешу, обхід захисту брандмауера та XSS.</desc>
	<solution>Використовуйте веб-сервер, який використовує сувору процедуру синтаксичного аналізу HTTP, наприклад, Apache (див. статтю у посиланні).

Використовуйте тільки SSL-зв'язок.

Завершуйте сеанс клієнта після кожного запиту.

Вимкніть кешування всіх сторінок.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>Контрабанда HTTP-відповіді</alert>
	<desc>Контрабанда HTTP-відповіді - це метод "контрабанди" 2 HTTP-відповідей від сервера до клієнта через проміжний HTTP-пристрій, який очікує (або дозволяє) одну відповідь від сервера.

Одне з застосувань цього методу - покращити базову техніку поділу HTTP-відповідей, щоб обійти заходи проти поділу HTTP-відповідей. У цьому випадку посередником є механізм розділення відповідей анти-HTTP між веб-сервером і проксі-сервером (або веб-браузером). Інший варіант використання - підробка відповідей, отриманих браузером. У цьому випадку шкідливий веб-сайт подає браузеру сторінку, яку браузер інтерпретує як таку, що походить з іншого (цільового) домену. Для цього можна використовувати контрабанду HTTP-відповіді, коли браузер використовує проксі-сервер для доступу до обох сайтів.

Контрабанда HTTP-відповіді використовує методи, подібні до контрабанди HTTP-запиту, щоб використовувати розбіжності між тим, що механізм поділу HTTP-відповіді (або проксі-сервер) вважає потоком HTTP-відповіді, і потоком відповіді, який розбирається проксі-сервером (або браузером). Отже, хоча механізм поділу HTTP-відповіді може вважати певний потік відповідей нешкідливим (одна HTTP-відповідь), проксі/браузер все одно може розпізнати його як дві HTTP-відповіді, а отже, бути вразливим до всіх наслідків вихідної техніки поділу HTTP-відповіді (у першому випадку) або бути вразливим до підміни сторінок (у другому випадку). Наприклад, деякі механізми захисту від поділу HTTP-відповіді, що використовуються деякими прикладними механізмами, забороняють додатку вставляти у відповідь заголовок, що містить CR+LF. Проте зловмисник може змусити додаток вставити заголовок, що містить CR, тим самим обійшовши захисний механізм. Деякі проксі-сервери все ще можуть розглядати CR (тільки) як роздільник заголовка (і відповіді), і тому комбінація веб-сервера і проксі-сервера все ще буде вразливою до атаки, яка може отруїти кеш проксі-сервера.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference/>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. Процес введення може змінити заплановану логіку роботи додатку та дозволити зловмиснику отримати несанкціонований доступ до системних файлів.

Більшість веб-додатків сьогодні розробляються з використанням мов вищого рівня, таких як PHP, ASP, Perl та Java. Однак ці веб-додатки в певний момент вимагають обробки високорівневого коду на системному рівні, і цей процес зазвичай досягається за допомогою функцій C/C++. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. У C/C++ нульовий байт є точкою завершення рядка або символом-роздільником, що означає негайне припинення обробки рядка. Байти після роздільника будуть проігноровані. Якщо рядок втрачає нульовий символ, довжина рядка стає невідомою, поки вказівник пам'яті не зустріне наступний нульовий байт. Це ненавмисне розгалуження може спричинити незвичну поведінку та призвести до появи вразливих місць у системі або застосунку. Аналогічно, деякі мови вищого рівня розглядають "нульовий байт" як заповнювач довжини рядка, оскільки він не має особливого значення в їхньому контексті. Через цю відмінність в інтерпретації можна легко ввести нульові байти, щоб керувати поведінкою додатку.

URL-адреси обмежені набором символів US-ASCII в діапазоні від 0x20 до 0x7E (шістнадцяткові) або від 32 до 126 (десяткові). Однак у вищезгаданому діапазоні використовується кілька символів, які не дозволені, оскільки вони мають особливе значення в контексті протоколу HTTP. З цієї причини було запроваджено схему кодування URL-адрес для включення спеціальних символів у URL-адреси з використанням розширеного представлення символів ASCII. З точки зору "нульового байта", це представлено у вигляді %00 у шістнадцятковій системі числення. Область видимості атаки нульовим байтом починається там, де веб-додатки взаємодіють з активними підпрограмами на мові C та зовнішніми API з базової операційної системи. Таким чином, дозволяючи зловмиснику керувати веб-ресурсами, читаючи або записуючи файли на основі привілеїв користувача додатку.</desc>
	<solution>Розробники повинні передбачити, що нульові символи або нульові байти будуть введеними/видаленими/керованими у вхідних векторах їхньої програмної системи. Використовуйте відповідну комбінацію чорних і білих списків, щоб гарантувати, що система обробляє лише достовірну, очікувану та відповідну інформацію.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стандартний механізм перевірки вхідних даних для перевірки довжини, типу, синтаксису та бізнес-правил перед тим, як приймати дані для відображення або зберігання. Використовуйте стратегію перевірки за принципом "приймати добре відомі".

Використовуйте та вказуйте надійне вихідне кодування (наприклад, ISO 8859-1 або UTF 8).

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато варіантів для кодування символів; ви, швидше за все, пропустите деякі варіанти.

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можуть бути використані для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>Впровадження LDAP </alert>
	<desc>Впровадження LDAP - це метод атаки, який використовується для експлуатації веб-сайтів, що створюють LDAP-запити на основі вхідних даних, наданих користувачем.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. Протокол LDAP працює поверх транспортних протоколів Інтернету, таких як TCP. Веб-додатки можуть використовувати введені користувачем дані для створення власних операторів LDAP для динамічних запитів до веб-сторінок.

Якщо веб-додаток не може належним чином очистити введені користувачем дані, зловмисник може змінити конструкцію LDAP-запиту. Якщо зловмисник змінить оператор LDAP, процес буде запущено з тими ж правами, що й компонент, який виконав команду. (наприклад, сервер бази даних, сервер веб-додатків, веб-сервер тощо). Це може спричинити серйозні проблеми з безпекою, якщо дозволи надають право запитувати, змінювати або видаляти будь-що всередині дерева LDAP. Ті ж самі просунуті методи експлуатації, доступні в SQL-введенні, також можуть бути застосовані в LDAP-введенні.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте відповідну комбінацію чорних і білих списків, щоб нейтралізувати синтаксис LDAP від контрольованого користувачем введення.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Впровадження поштових команд</alert>
	<desc>Впровадження поштових команд - це метод атаки, який використовується для експлуатації поштових серверів і веб-додатків, що створюють IMAP/SMTP-запити на основі введених користувачем даних, які не пройшли належну санітарну обробку. Залежно від типу твердження, яким користується зловмисник, ми зустрічаємося з двома типами впровадження: IMAP та SMTP впровадження. Впровадження IMAP/SMTP може дозволити отримати доступ до поштового сервера, до якого ви раніше не мали доступу. У деяких випадках ці внутрішні системи не мають такого ж рівня захисту інфраструктури, як більшість зовнішніх веб-серверів. Таким чином, зловмисники можуть виявити, що поштовий сервер дає кращі результати з точки зору експлуатації. З іншого боку, ця техніка дозволяє обійти можливі обмеження, які можуть існувати на рівні додатку (CAPTCHA, максимальна кількість запитів тощо).</desc>
	<solution>Зрозумійте всі можливі місця, де ненадійні дані можуть потрапити у ваше програмне забезпечення: параметри або аргументи, файли cookie, все, що зчитується з мережі, змінні середовища, заголовки запитів, а також вміст, компоненти URL-адрес, електронна пошта, файли, бази даних і будь-які зовнішні системи, які надають дані додатку. Виконуйте перевірку вхідних даних на чітко визначених інтерфейсах.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних за принципом "прийняти відомі дані" (тобто, використовуйте список дозволених даних). Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Використовуйте список заборон, щоб відхиляти будь-які неочікувані вхідні дані та виявляти можливі атаки.

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато варіантів для кодування символів; ви, швидше за все, пропустите деякі варіанти.

Безпосередньо перетворіть тип вхідних даних в очікуваний тип даних, наприклад, за допомогою функції перетворення, яка переводить рядок у число. Після перетворення до очікуваного типу даних переконайтеся, що значення вхідних даних потрапляють в очікуваний діапазон допустимих значень і що зберігається багатопрофільна узгодженість.

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можуть бути використані для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки. Використовуйте такі бібліотеки, як елемент керування канонізацією OWASP ESAPI.

Повторюйте канонізацію доти, доки ваші дані не перестануть змінюватися. Це дозволить уникнути подвійного декодування та схожих сценаріїв, але може ненавмисно змінити вхідні дані, які можуть містити належним чином закодований небезпечний вміст.

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно вказуйте кодування, яке ви використовуєте, якщо це дозволяє протокол.

Якщо ваш додаток об'єднує дані з декількох джерел, виконайте перевірку після того, як джерела будуть об'єднані. Окремі елементи даних можуть пройти етап перевірки, але після об'єднання порушувати встановлені обмеження.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>Виконання команд ОС</alert>
	<desc>Виконання команд ОС - це техніка атаки, яка використовується для несанкціонованого виконання команд операційної системи.

Виконання команд ОС - є прямим результатом змішування довіреного коду та ненадійних даних. Ця атака можлива, коли програма приймає ненадійні вхідні дані для побудови команд операційної системи в небезпечний спосіб, включаючи неналежну санітарну обробку даних і/або неналежний виклик зовнішніх програм. У виконанні команд ОС команди, виконані зловмисником, будуть запущені з тими ж привілеями компонента, який виконав команду (наприклад, сервер бази даних, сервер веб-додатків, веб-сервер, оболонка, додаток). Оскільки команди виконуються під привілеями виконуваного компонента, зловмисник може скористатися цим, щоб отримати доступ або пошкодити частини, які інакше недоступні (наприклад, каталоги та файли операційної системи).</desc>
	<solution>Якщо це можливо, використовуйте виклики бібліотек, а не зовнішні процеси для відтворення потрібної функціональності.

Запустіть свій код у "в'язниці" або подібному середовищі ізольованого програмного середовища, яке забезпечує суворі межі між обробкою та операційною системою. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.

Для будь-яких даних, які будуть використані для створення команди, що виконується, тримайте якомога більше цих даних поза зовнішнім контролем. Наприклад, у вебзастосунках для цього може знадобитися зберігати команду локально в стані сеансу замість того, щоб надсилати її клієнту у прихованому полі форми.

Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

Наприклад, розгляньте можливість використання елемента керування ESAPI Encoding або подібного інструменту, бібліотеки чи фреймворку. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

Якщо вам потрібно використовувати динамічно створені рядки запиту або команди, попри ризик, належним чином наведіть аргументи та виключіть будь-які спеціальні символи в цих аргументах. Найбільш консервативний підхід полягає в тому, щоб уникнути або відфільтрувати всі символи, які не проходять надзвичайно суворий список дозволених (наприклад, усе, що не є буквено-цифровим або пробілом). Якщо деякі спеціальні символи все ще потрібні, наприклад пробіл, візьміть кожен аргумент у лапки після етапу екранування/фільтрування. Будьте обережні з введенням аргументів.

Якщо програма, яку потрібно виконати, дозволяє задавати аргументи у вхідному файлі або за допомогою стандартного вводу, розгляньте можливість використання цього режиму, щоб передати аргументи замість командного рядка.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Деякі мови пропонують кілька функцій, які можна використовувати для виклику команд. Якщо можливо, визначте будь-яку функцію, яка викликає командну оболонку за допомогою одного рядка, і замініть її функцією, яка потребує окремих аргументів. Ці функції зазвичай виконують відповідне цитування та фільтрацію аргументів. Наприклад, у C функція system() приймає рядок, який містить повну команду для виконання, тоді як execl(), execve() та інші потребують масиву рядків, по одному для кожного аргументу. У Windows CreateProcess() приймає лише одну команду за раз. У Perl, якщо system() надається з масивом аргументів, тоді він візьме в лапки кожен з аргументів.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Під час створення командних рядків ОС використовуйте суворі дозволені списки, які обмежують набір символів на основі очікуваного значення параметра в запиті. Це опосередковано обмежить область атаки, але цей метод менш важливий, ніж правильне кодування виводу та екранування.

Зауважте, що правильне кодування виводу, екранування та цитування є найефективнішим рішенням для запобігання впровадження команд ОС, хоча перевірка введення може забезпечити певний поглиблений захист. Це пов’язано з тим, що він фактично обмежує те, що показуватиметься у виводі. Перевірка введених даних не завжди запобігатиме впровадженню команд ОС, особливо якщо від вас вимагається підтримка текстових полів довільної форми, які можуть містити довільні символи. Наприклад, під час виклику поштової програми вам може знадобитися дозволити вводити до поля теми небезпечні символи, такі як ";" та ">", які потрібно екранувати або обробляти іншим чином. У цьому випадку видалення символу може зменшити ризик впровадження команди ОС, але це призведе до неправильної поведінки, оскільки поле теми не буде записане так, як хотів користувач. Це може здатися незначною незручністю, але це може бути більш важливим, коли програма покладається на добре структуровані рядки теми для передачі повідомлень іншим компонентам.

Навіть якщо ви припустилися помилки під час перевірки, наприклад, забули одне зі 100 полів введення, правильне кодування все одно захистить вас від атак на основі ін'єкцій. До тих пір, поки це не робиться ізольовано, перевірка вхідних даних все ще є корисною технікою, оскільки вона може значно зменшити вашу поверхню атаки, дозволити виявити деякі атаки та надати інші переваги безпеки, які не враховуються правильним кодуванням.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Обхід маршрутизації</alert>
	<desc>Протокол WS-Routing (WS-Routing) - це протокол для обміну SOAP-повідомленнями від початкового відправника повідомлення до кінцевого одержувача, як правило, через набір посередників. Протокол WS-Routing реалізований як розширення SOAP і вбудований в заголовок SOAP. WS-Routing часто використовується для спрямування XML-трафіку через складні середовища і транзакції, дозволяючи проміжним станціям на шляху XML призначати інструкції маршрутизації XML-документу.

Обходи маршрутизації - це тип атаки "людина посередині", коли посередники можуть бути введені або "викрадені" для перенаправлення конфіденційних повідомлень у зовнішнє місце. Інформація про маршрутизацію (або в заголовку HTTP, або в заголовку WS-Routing) може бути змінена на шляху проходження, а сліди маршрутизації можуть бути видалені з заголовка і повідомлення таким чином, що програма-одержувач навіть не здогадається, що відбувся обхід маршрутизації. Заголовок і вставка об'єктів заголовка часто менш захищені, ніж повідомлення; це пов'язано з тим, що заголовок використовується як універсальний засіб для метаданих про транзакцію, таких як автентифікація, маршрутизація, форматування, схема, канонізація, простори імен і т.д. Крім того, у додаванні або обробці заголовка XML-документа може бути залучено багато процесів. У багатьох реалізаціях інформація про маршрутизацію може надходити від зовнішнього вебсервісу, наприклад, WS-Referral, який забезпечує конкретну маршрутизацію для транзакції.

WS-Addressing - це новіший стандарт, опублікований W3C для забезпечення функціональності маршрутизації SOAP-повідомлень. Однією з ключових відмінностей між WS-Routing та WS-Addressing є те, що WS-Addressing надає лише наступне місце в маршрутизації. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Завжди повністю автентифікуйте обидва кінці будь-якого каналу зв'язку.

Дотримуйтесь принципу повної медіації.

Сертифікат прив'язує особу до криптографічного ключа для автентифікації комунікативної сторони. Часто сертифікат має зашифровану форму хешу ідентичності суб'єкта, відкритого ключа та такої інформації, як час видачі або закінчення терміну дії за допомогою закритого ключа емітента. Сертифікат можна перевірити, розшифрувавши його за допомогою відкритого ключа видавця. Дивіться також ланцюжки підписів сертифікатів X.509 і структуру сертифікації PGP.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Обхід шляху</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. Зловмисник може маніпулювати URL-адресою таким чином, що вебсайт виконає або розкриє вміст довільних файлів у будь-якій точці вебсервера. Будь-який пристрій, що надає доступ до інтерфейсу на основі HTTP, потенційно вразливий до обходу шляхів.

Більшість вебсайтів обмежують доступ користувачів до певної частини файлової системи, яка зазвичай називається "кореневим каталогом вебдокумента" або "кореневим каталогом CGI". Ці каталоги містять файли, призначені для доступу користувачів, а також виконувані файли, необхідні для роботи вебзастосунків. Щоб отримати доступ до файлів або виконати команди в будь-якому місці файлової системи, атаки обходу шляху використовують можливості послідовностей спеціальних символів.

Найпростіша атака обходу шляху використовує послідовність спеціальних символів "./" для зміни місця розташування ресурсу, запитуваного в URL-адресі. Хоча більшість популярних вебсерверів не дозволять цьому методу екранувати корінь вебдокумента, альтернативні кодування послідовності "./" можуть допомогти обійти фільтри безпеки. Ці варіації методу включають припустиме і неприпустиме кодування Unicode (".%u2216" або ".%c0%af") символу прямої похилої риски, символів зворотної похилої риски ("..\") на серверах під управлінням Windows, символів URL-адреси "%2e%2e%2f") і подвійного кодування URL-адреси (".%255c") для символу зворотної похилої риски.

Навіть якщо вебсервер належним чином обмежує спроби обходу шляху в URL-адресі, сам вебзастосунок може бути вразливим через неправильну обробку введених користувачем даних. Це поширена проблема вебзастосунків, які використовують шаблонні механізми або завантажують статичний текст з файлів. У варіаціях атаки оригінальне значення параметра URL замінюється на ім'я файлу одного з динамічних скриптів вебзастосунку. Отже, результати можуть показувати вихідний код, оскільки файл інтерпретується як текст, а не як виконуваний сценарій. Ці методи часто використовують додаткові спеціальні символи, такі як крапка ("."). щоб показати список поточного робочого каталогу або "%00" NULL-символи, щоб обійти елементарні перевірки розширення файлів.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. Якщо це можливо, дозвольте лише один символ "." у назві файлу, щоб уникнути вразливостей, і виключіть роздільники каталогів, такі як "/". Використовуйте список дозволених розширень файлів.

Попередження: якщо ви намагаєтеся очистити свої дані, то робіть це так, щоб кінцевий результат не був у формі, яка може бути небезпечною. Механізм очищення може видаляти такі символи, як '.' і ';', які можуть знадобитися для деяких експлойтів. Зловмисник може спробувати обдурити механізм очищення, "очистивши" дані до небезпечної форми. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". Якщо вхідні дані тепер вважаються безпечними, то файл може бути скомпрометований. 

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можна використовувати для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки.

Використовуйте вбудовану функцію канонізації шляху, наприклад, realpath() у C, яка створює канонічну версію назви шляху, що ефективно видаляє послідовності "..." та символічні посилання.

Запускайте свій код з найнижчими привілеями, які потрібні для виконання необхідних завдань. Якщо можливо, створюйте ізольовані облікові записи з обмеженими правами, які використовуються лише для однієї задачі. Таким чином, успішна атака не надасть зловмиснику доступ до решти програмного забезпечення або його середовища. Наприклад, застосунки баз даних рідко потребують запуску від імені адміністратора бази даних, особливо в повсякденних операціях.

Якщо набір прийнятих об'єктів, таких як імена файлів або URL-адреси, обмежений або відомий, створіть зіставлення з набору фіксованих вхідних значень, наприклад, числових ідентифікаторів на фактичні імена файлів або URL-адреси, і відхиліть всі інші вхідні дані.

Запустіть свій код у "в'язниці" або подібному середовищі ізольованого програмного середовища, яке забезпечує суворі межі між обробкою та операційною системою. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.

Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Передбачуване розташування ресурсів</alert>
	<desc>Передбачуване розташування ресурсів - це метод атаки, який використовується для виявлення прихованого вмісту та функціональності вебсайтів. Роблячи обґрунтовані припущення шляхом перебору, зловмисник може вгадати імена файлів і каталогів, які не призначені для публічного перегляду. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. Це можуть бути тимчасові файли, файли резервних копій, журнали, адміністративні розділи сайту, конфігураційні файли, демонстраційні застосунки та файли зразків. Ці файли можуть розкривати конфіденційну інформацію про вебсайт, внутрішній устрій вебзастосунків, інформацію баз даних, паролі, імена комп'ютерів, шляхи до файлів в інших конфіденційних областях тощо.

Це не тільки допоможе ідентифікувати поверхню сайту, що може призвести до додаткових вразливостей сайту, але також може розкрити зловмиснику цінну інформацію про середовище або його користувачів. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Застосовуйте відповідні повноваження контролю доступу для кожного доступу до всіх обмежених URL-адрес, скриптів або файлів.

Розгляньте можливість використання фреймворків на основі MVC, таких як Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>Зловживання масивом SOAP</alert>
	<desc>Масиви XML SOAP є поширеною ціллю для зловмисників. Масиви SOAP визначаються як такі, що мають тип "SOAP-ENC:Array" або похідний від нього тип. Масиви SOAP мають один або декілька вимірів (рангів), члени яких розрізняються за порядковим номером. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. Для багатовимірних масивів розмір у правій частині змінюється найшвидше. Кожен елемент-член називається незалежним елементом. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Запустіть програму, використовуючи надані системні обмеження ресурсів для пам'яті. Це все одно може призвести до аварійного завершення роботи програми або виходу з неї, але вплив на решту системи буде зведено до мінімуму.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference/>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Фіксація сеансу</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>Зловживання перенаправленням URL-адрес</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. Це може бути зроблено з різних причин і часто робиться для того, щоб дозволити переміщення ресурсів у структурі каталогу та уникнути порушення функціональності для користувачів, які запитують ресурс у його попередньому розташуванні. Перенаправлення URL-адрес також можна використовувати для реалізації балансування навантаження, використовуючи скорочені URL-адреси або запису вихідних посилань. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Use an allow list of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

Якщо набір прийнятих об'єктів, таких як імена файлів або URL-адреси, обмежений або відомий, створіть зіставлення з набору фіксованих вхідних значень, наприклад, числових ідентифікаторів на фактичні імена файлів або URL-адреси, і відхиліть всі інші вхідні дані.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

Багато проблем з відкритим перенаправленням виникають через те, що програміст припускав, що певні вхідні дані не можуть бути змінені, наприклад, файли cookie або приховані поля форм.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>Впровадження XPath</alert>
	<desc>XPath Injection - це метод атаки, який використовується для експлуатації додатків, що створюють запити XPath (XML Path Language) на основі введених користувачем даних для запиту або навігації по XML-документам. Він може використовуватися безпосередньо програмою для запиту XML-документа, як частина більшої операції, такої як застосування XSLT-перетворення до XML-документа або застосування XQuery до XML-документа. Синтаксис XPath має деяку схожість з SQL-запитом, і справді, за допомогою XPath можна формувати SQL-подібні запити до XML-документа.

Якщо застосунок використовує конструкцію запитів XPath під час виконання, вбудовуючи в запит небезпечний користувацький ввід, зловмисник може вставити в запит дані так, що новостворений запит буде оброблений не так, як задумав програміст.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). Це допоможе забезпечити поділ між площиною даних і площиною управління.

Належним чином перевіряйте дані користувача. Reject data where appropriate, filter where appropriate and escape where appropriate. Переконайтеся, що вхідні дані, які будуть використовуватися в запитах XPath, є безпечними в цьому контексті.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Недостатня перевірка процесу</alert>
	<desc>Недостатня перевірка процесу виникає, коли вебзастосунок не може перешкодити зловмиснику обійти запланований потік або бізнес-логіку застосунку. У реальному світі недостатня перевірка процесів призвела до неефективного контролю доступу та грошових втрат.

Існує два основних типи процесів, які потребують перевірки: управління потоком та бізнес-логіка.

"Управління потоком" належить до багатокрокових процесів, які вимагають від користувача виконання кожного кроку в певному порядку. Якщо зловмисник виконує цей крок неправильно або не в тому порядку, контроль доступу може бути обійдений, що може призвести до помилки цілісності програми. Прикладами багатокрокових процесів є банківський переказ, відновлення пароля, оформлення покупки та реєстрація облікового запису.

"Бізнес-логіка" належить до контексту, в якому процес буде виконуватися відповідно до бізнес-вимог. Використання недоліків бізнес-логіки вимагає знання бізнесу; якщо для цього не потрібні знання, то, швидше за все, це не є недоліком бізнес-логіки. Через це типові заходи безпеки, такі як сканування та аналіз коду, не знайдуть цей клас вразливостей. Один із підходів до тестування пропонує OWASP у своєму Посібнику з тестування.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference/>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. Найкращий захист - обмежити кількість ресурсів, які може витратити несанкціонований користувач. Надійна модель автентифікації та контролю доступу допоможе в першу чергу запобігти таким атакам. Застосунок для входу повинен бути максимально захищений від DoS-атак. Обмеження доступу до бази даних, можливо, шляхом кешування наборів результатів, може допомогти мінімізувати витрачені ресурси. Щоб ще більше обмежити потенціал DoS-атаки, розгляньте можливість відстеження швидкості запитів, отриманих від користувачів, і блокування запитів, які перевищують певний поріг швидкості.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

Перше з цих рішень є проблемою саме по собі, оскільки воно може дозволити зловмисникам запобігти використанню системи певним дійсним користувачем. Якщо зловмисник видає себе за дійсного користувача, він може заборонити користувачеві доступ до відповідного сервера.

Друге рішення просто важко ефективно впровадити - і навіть якщо це зроблено належним чином, воно не забезпечує повного розв'язання проблеми. Це просто робить атаку більш ресурсомісткою для зловмисника.

Переконайтеся, що протоколи мають конкретні обмеження щодо масштабу.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Зловживання функціональністю</alert>
	<desc>Зловживання функціональністю - це метод атаки, який використовує власні можливості та функціонал вебсайту для атаки на нього самого або на інших. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. Ці атаки призводять до різних результатів, таких як споживання ресурсів, обхід контролю доступу або витік інформації. Потенціал і рівень зловживань буде змінюватися від вебсайту до вебсайту і від програми до програми. Атаки на зловживання функціональністю часто є комбінацією інших типів атак або використовують інші вектори атаки.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>Зовнішні об'єкти XML</alert>
	<desc>Цей метод використовує перевагу XML динамічно створювати документи під час обробки. Повідомлення XML може надавати дані в явному вигляді або шляхом вказівки на URI, де ці дані існують. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Зловмисники також можуть використовувати зовнішні об'єкти, щоб змусити сервер вебслужб завантажити шкідливий код або вміст на сервер для використання у вторинних або наступних атаках.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference/>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference/>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. Це допоможе забезпечити поділ між площиною даних і площиною управління.

Належним чином перевіряйте дані користувача. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Недостатній термін дії сеансу</alert>
	<desc>Недостатній термін дії сеансу виникає, коли вебзастосунок дозволяє зловмиснику повторно використовувати старі облікові дані сеансу або ідентифікатори сеансу для авторизації. Недостатній термін дії сеансу підвищує вразливість вебсайту до атак, які викрадають або повторно використовують ідентифікатори сеансу користувача.

Оскільки HTTP є протоколом без статусу, вебсайти зазвичай використовують файли cookie для зберігання ідентифікаторів сеансів, які унікально ідентифікують користувача від запиту до запиту. Отже, необхідно підтримувати конфіденційність кожного ідентифікатора сеансу, щоб запобігти доступу декількох користувачів до одного і того ж облікового запису. Викрадений ідентифікатор сеансу може бути використаний для перегляду облікового запису іншого користувача або здійснення шахрайської транзакції.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. Тривалий термін дії збільшує шанси зловмисника успішно вгадати дійсний ідентифікатор сеансу. The longer the expiration time, the more concurrent open sessions will exist at any given time. Чим більший пул сесій, тим більша ймовірність того, що зловмисник випадково вгадає одну з них. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user’s session and disallow reuse of the session token.</desc>
	<solution>Встановіть термін дії сеансів або облікових даних.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it’s not easy to distinguish the attacker’s queries from a legitimate user’s queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference/>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Недостатнє відновлення пароля</alert>
	<desc>Недостатнє відновлення пароля - це коли вебсайт дозволяє зловмиснику незаконно отримати, змінити або відновити пароль іншого користувача. Звичайні методи автентифікації на вебсайтах вимагають від користувачів вибору та запам'ятовування пароля або парольної фрази. Користувач повинен бути єдиною людиною, яка знає пароль, і його необхідно точно запам'ятати. З часом здатність користувача запам'ятовувати пароль слабшає. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (Опитування RSA: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Таким чином, відновлення паролів є важливою частиною обслуговування користувачів в Інтернеті.

Приклади автоматизованих процесів відновлення паролів включають вимогу до користувача відповісти на "секретне питання", визначене як частина процесу реєстрації користувача. Це запитання можна вибрати зі списку готових запитань або надати користувачеві. Іншим механізмом є надання користувачем "підказки" під час реєстрації, яка допоможе користувачеві запам'ятати свій пароль. Інші механізми вимагають від користувача надання декількох персональних даних, таких як номер соціального страхування, домашня адреса, поштовий індекс тощо, щоб підтвердити свою особу. Після того, як користувач підтвердить свою особу, система відновлення виведе на екран або надішле на електронну пошту новий пароль.

Вважається, що вебсайт має недостатній рівень відновлення пароля, якщо зловмисник може зламати механізм відновлення, який використовується. Це трапляється, коли інформація, необхідна для підтвердження особи користувача для відновлення, або легко вгадується, або її можна обійти. Системи відновлення паролів можуть бути скомпрометовані за допомогою методів "грубої сили", вразливостей системи або легко вгадуваних секретних запитань.</desc>
	<solution>Переконайтеся, що всі дані, які користувач вводить до механізму відновлення пароля, ретельно відфільтровані та перевірені

Не використовуйте стандартні слабкі контрольні питання та використовуйте декілька контрольних питань.

Переконайтеся, що кількість неправильних відповідей на контрольне питання обмежена. Вимкніть функцію відновлення пароля після певної (невеликої) кількості неправильних вгадувань.

Вимагайте, щоб користувач правильно відповів на контрольне питання  перед тим, як скинути його пароль і надіслати новий пароль на адресу електронної пошти, вказану в записі.

Ніколи не дозволяйте користувачеві контролювати, на яку адресу електронної пошти буде надіслано новий пароль у механізмі відновлення пароля.

Призначте новий тимчасовий пароль замість того, щоб розкривати вихідний пароль.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>
